For this job, we began by reading the command line input, then getting the jobs from the .in files given. We read line by line in a seperate function for input. We got the length, job ID then set the rest of the variables we added to default 0. From there, we sorted using swap sort, but only if it was SJF. The job struct includes the ID, length, start_time and end_time (for analysis), robin_complete (to mark if its done for robin complete), accessed (used to see if it has been accessed), time left (used with round robin to see how much time is left), then job next (to create the linked list struct). Round robin runs each job for a certain amount of time based off of the time left struct, which is set when the job is seen for the first time. If will continue until all the jobs are completed (which is tracted by the global variable for number of jobs). SJF and FIFO function the same way, expect SJF is sorted first. They go through each job by iterating through the linked list and calulcating the running time. Running time is tracked through a global variable which is added to as every job completes. The analysis is 2 seperate functions, 1 for RR and 1 for SJF and FIFO. RR time is calculated different due to having multiple runs. All smaller details are shown in comments in the code. 

For workload 1, all of the jobs are the same length of 3, so they all have equal wait and response time since they are done after one rotation of RR. Workload 2 has one job first that took 1000 seconds then the rest of the jobs were short. This shows the clear disadvantages of FIFO when it comes to having a consuming first job when compared to SJF. Workload 3 is jobs all of length 1, the wait time, response, and turn around is the same between all 3 scheduling methods since there is no advantages or disadvantages of any order since all jobs are the same and round robin will only have 1 run on each job since they are shorter than the time slice. Workload 4 is the opposite of 2 and has short jobs then one long job at the end. Workload 5 has 3, 9 and 12 has the job lengths. They can be calculated through using the equations for response time and turnaround time. 

